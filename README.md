# Go vs Rust: Lock Contention & Memory Benchmark

Репозиторий к видео "Я написал плохой код на Rust, и Go его уничтожил". Здесь мы сравниваем производительность многопоточной записи в общую HashMap.

## Структура проекта
- `go_app`: Реализация на Go (Mutex, Sharding).
- `rust_app`: Реализация на Rust (Mutex, DashMap, SmallVec).

## Подготовка
Для запуска вам понадобятся:
1. **Rust** (stable)
2. **Go** (1.20+)
3. **Hyperfine** (утилита для бенчмарков)
    - *macOS:* `brew install hyperfine`
    - *Linux:* `apt install hyperfine`

## Как запустить
Просто запустите автоматический скрипт из корня репозитория:

```bash
chmod +x build_and_run.sh
# Запуск в режиме Debug (медленно)
./build_and_run.sh

# Запуск в режиме Release (максимальная производительность)
./build_and_run.sh release
```
**Важно:** Использование флага release активирует оптимизации компилятора Rust. В этом режиме код выполняется значительно быстрее, что критично для корректного сравнения производительности с Go в бенчмарках.

## Что мы сравниваем?
* Unclear (Naive): Обычный Mutex вокруг всей мапы. Rust проигрывает из-за Lock Contention.

* Clear (Optimized): - В Rust: DashMap + SmallVec (уход на стек).

* В Go: Ручное шардирование мапы.

Особенности сборки
Обратите внимание на Cargo.toml. Настройки профиля [profile.release] могут радикально менять результаты. При передаче аргумента release в наш скрипт, бинарник собирается из директории target/release/, обеспечивая честное сравнение мощностей языков.